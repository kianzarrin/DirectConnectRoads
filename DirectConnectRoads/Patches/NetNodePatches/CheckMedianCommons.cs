using HarmonyLib;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using KianCommons;
using KianCommons.Plugins;
using System;

namespace DirectConnectRoads.Patches {
    using DirectConnectRoads.Util;
    using static KianCommons.Patches.TranspilerUtils;

    public static class CheckMedianCommons {
        public static bool ShouldConnectMedian(
            ushort nodeId,
            int nodeInfoIDX,
            in RenderManager.Instance data) {
            try {
                //Log.VERBOSE = true;
                ushort sourceSegmentID = nodeId.ToNode().GetSegment(data.m_dataInt0 & 7);
                int targetSegmentIDX = data.m_dataInt0 >> 4;
                ushort targetSegmentID = nodeId.ToNode().GetSegment(targetSegmentIDX);
                NetInfo info = sourceSegmentID.ToSegment().Info;
                NetInfo.Node nodeInfo = info.m_nodes[nodeInfoIDX];
                if (!info.IsRoad())
                    return true; // ignore
                if (!DCUtil.IsMedian(nodeInfo, info)) {
                    if (Log.VERBOSE) {
                        Log.Debug($"not a median: node:{nodeId} segmentId:{sourceSegmentID} " +
                            $"connect_group:{nodeInfo.m_connectGroup} " +
                            $"vehcileTypes:{info.m_vehicleTypes}", false);
                    }
                    return true; // ignore.
                }

                if (info.GetIsAdaptive()) {
                    if (!nodeInfo.HideBrokenARMedians())
                        return true; // ignore
                } else {
                    if (NetInfoUtil.UnsupportedRoadWithTrackTable.Contains(info)) {
                        if (Log.VERBOSE) Log.Debug($"{info} is UnsupportedRoadWithTrack", false);
                        return true; // ignore
                    }
                    if (!info.IsNormalSymetricalTwoWay(out int pedestrianLaneCount))
                        return true; // ignore

                    if(pedestrianLaneCount > 2) {
                        bool hasCrossing =
                            TMPEUtil.HasCrossing(segmentId: sourceSegmentID, nodeId: nodeId) ||
                            TMPEUtil.HasCrossing(segmentId: targetSegmentID, nodeId: nodeId);
                        if (hasCrossing)
                            return false; // disconnect;
                    }
                }

                bool autogenerated = NetInfoUtil.AddedNodes.Contains(nodeInfo);
                NetInfo sourceInfo = sourceSegmentID.ToSegment().Info;
                NetInfo targetInfo = targetSegmentID.ToSegment().Info;
                if (autogenerated && !Connects(sourceInfo, targetInfo)) {
                    return false; // disconnect auto-generated
                }

                if (DCRConfig.Config.ExemptionsSet.Contains(info.name)) {
                    if (Log.VERBOSE) Log.Debug($"{info} is Exempt");
                    return !autogenerated; // ignore
                }

                if (!API.InvokeShouldManageDCNodes(info, sourceSegmentID, targetSegmentID)) {
                    if (Log.VERBOSE) Log.Debug($"should not Manage DC Nodes for {info}",false);
                    return !autogenerated; // ignore
                }

                bool openMedian = DirectConnectUtil.OpenMedian(sourceSegmentID, targetSegmentID);
                if (Log.VERBOSE) Log.Debug($"OpenMedian(sourceSegmentID:{sourceSegmentID}, targetSegmentID:{targetSegmentID})->{openMedian}",false);
                return !openMedian;
            }
            catch (Exception ex) {
                ex.Log();
                return true; // do nothing.
            } finally {
                Log.VERBOSE = false;
            }
        }

        public static bool Connects(NetInfo source, NetInfo target) {
            if (!source.IsCombatible(target))
                return false;
            if ( (source.m_vehicleTypes ^ target.m_vehicleTypes)  != VehicleInfo.VehicleType.None) 
                return false;
            return true;
        }

        static FieldInfo f_m_nodes => typeof(NetInfo).GetField("m_nodes");

        public static void ApplyCheckMedian(List<CodeInstruction> codes, MethodBase method, int occurance) {

            MethodInfo mShouldConnectMedian = typeof(CheckMedianCommons).GetMethod("ShouldConnectMedian", throwOnError:true);
            MethodInfo mCheckRenderDistance = typeof(RenderManager.CameraInfo).GetMethod("CheckRenderDistance", throwOnError: true);
            /*
            --->insert here
            [164 17 - 164 95]
            IL_02c0: ldarg.1      // cameraInfo
            IL_02c1: ldarg.s      data
            IL_02c3: ldfld        valuetype [UnityEngine]UnityEngine.Vector3 RenderManager/Instance::m_position
            IL_02c8: ldloc.s      node // <--= LDLoc_NodeInfo
            IL_02ca: ldfld        float32 NetInfo/Node::m_lodRenderDistance
            IL_02cf: callvirt     instance bool RenderManager/CameraInfo::CheckRenderDistance(valuetype [UnityEngine]UnityEngine.Vector3, float32)
            IL_02d4: brfalse      IL_0405
             */

            CodeInstruction LDArg_NodeID = GetLDArg(method, "nodeID");
            CodeInstruction LDArg_data = GetLDArg(method, "data");

            int index = 0;
            index = codes.Search(c => c.Calls(mCheckRenderDistance), startIndex:index, count: occurance);
            Assertion.Assert(index != 0, "index!=0");
            CodeInstruction LDLoc_NodeInfoIDX = Search_LDLoc_NodeInfoIDX(codes, index);

            //seek to <ldarg.s cameraInfo> instruction:
            index = codes.Search(c => c.IsLdarg(method, "cameraInfo"), startIndex: index, count:-1);

            Label ContinueIndex = GetContinueLabel(codes, index, dir: -1); // IL_029d: br IL_0570
            {
                var newInstructions = new[]{
                    LDArg_NodeID,
                    LDLoc_NodeInfoIDX,
                    LDArg_data,
                    new CodeInstruction(OpCodes.Call, mShouldConnectMedian),
                    new CodeInstruction(OpCodes.Brfalse, ContinueIndex), // if returned value is false then continue to the next iteration of for loop;
                };

                InsertInstructions(codes, newInstructions, index, true);
            } // end block
        } // end method

        public static CodeInstruction Search_LDLoc_NodeInfoIDX(List<CodeInstruction> codes, int index) {
            FieldInfo f_m_nodes = ReflectionHelpers.GetField<NetInfo>("m_nodes");
            index = codes.Search(c=>c.LoadsField(f_m_nodes), index, count: -1);

            var code = codes[index + 1];
            Assertion.Assert(code.IsLdloc(), $"IsLdLoc(code) | code={code}");
            return code;
        }
    }
}
